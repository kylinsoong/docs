= 基本概念
:toc: manual

== 基础示例

本部分通过一个示例展示 K8S 的基本操作，具体包括：创建集群、部署应用、外部访问应用、扩展应用、升级应用等。

[cols="2,5a"]
|===
|编号 |命令

|1
|
[source, bash]
.*集群版本*
----
kubectl version
----

|2
|
[source, bash]
.*集群详情*
----
kubectl cluster-info
kubectl cluster-info dump
----

|3 
|
[source, bash]
.*查节点*
----
kubectl get nodes
kubectl get nodes -o wide
kubectl get nodes -o wide --show-labels
----

|4
|
[source, bash]
.*查 Pod*
----
kubectl get pods
kubectl get pods --all-namespaces
kubectl get pods --all-namespaces -o wide
kubectl get pods --all-namespaces --show-labels
----

|5 
|
[source, bash]
.*创建 Deployment*
----
kubectl create deployment helloworld --image=gcr.io/google-samples/kubernetes-bootcamp:v1
----

|6
|
[source, bash]
.*查看所有*
----
kubectl get all
----

|7 
|
[source, bash]
.*启用 Proxy*
----
$ kubectl proxy
Starting to serve on 127.0.0.1:8001

curl http://127.0.0.1:8001/version
curl http://127.0.0.1:8001/api/v1/namespaces/default/pods/$POD_NAME
----

|8 
|
[source, bash]
.*查看 Pod 日志*
----
kubectl logs helloworld-7bf845589-mb92f
----

|9
|
[source, bash]
.*在 Pod 中执行命令*
----
kubectl exec helloworld-7bf845589-mb92f env
kubectl exec helloworld-7bf845589-mb92f ip a
kubectl exec helloworld-7bf845589-mb92f hostname
kubectl exec helloworld-7bf845589-mb92f curl http://127.0.0.1:8080

kubectl exec -it helloworld-7bf845589-mb92f bash
----

|10 
|
[source, bash]
.*查看服务*
----
kubectl get svc
----

|11 
|
[source, bash]
.*NodePort 暴露*
----
kubectl expose deployment helloworld --type='NodePort' --port=8080

curl http://192.168.100.101:31012
----

|12
|
[source, bash]
.*kubectl describe*
----
kubectl describe deployment helloworld
kubectl describe pod/helloworld-7bf845589-mb92f
kubectl describe service/helloworld
kubectl describe replicaset helloworld-7bf845589
----

|13
|
[source, bash]
.*Pod 与标签*
----
kubectl get pod --show-labels
kubectl get pod helloworld-7bf845589-mb92f --show-labels
kubectl label pod helloworld-7bf845589-mb92f tester=kylin
kubectl get pods -l tester=kylin
kubectl label pod helloworld-7bf845589-mb92f tester-
----

|14
|
[source, bash]
.*查看 replicaset*
----
kubectl get rs
----

|15
|
[source, bash]
.*扩展 Deployment*
----
kubectl scale deployment/helloworld --replicas=4
----

|16
|
[source, bash]
.*滚动升级: 默认部署策略为 RollingUpdate*
----
kubectl set image deployments/helloworld kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v2

kubectl rollout status deployments/helloworld
----

|17 
|
[source, bash]
.*回滚*
----
kubectl rollout undo deployment/helloworld
kubectl rollout history deployments/helloworld

----

|18 
|
[source, bash]
.*删除所有*
----
kubectl delete all --all
----
|===

== ConfigMap

=== Redis 配置文件(Volume 对接 ConfigMap) 

本部分演示将 Redis 的配置文件通过 ConfigMap 传递。

[source, yaml]
.*1. 创建 redis-config*
----
// prepare files
cat <<EOF > ./redis-config
maxmemory 2mb
maxmemory-policy allkeys-lru
EOF

// create configMap
kubectl create configmap redis-config --from-file=redis-config
----

[source, yaml]
.*2. 创建一个 POD*
----
// prepare yaml files
cat <<EOF > ./pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis:5.0.4
    command:
      - redis-server
      - "/redis-master/redis.conf"
    env:
    - name: MASTER
      value: "true"
    ports:
    - containerPort: 6379
    resources:
      limits:
        cpu: "0.1"
    volumeMounts:
    - mountPath: /redis-master-data
      name: data
    - mountPath: /redis-master
      name: config
  volumes:
    - name: data
      emptyDir: {}
    - name: config
      configMap:
        name: redis-config
        items:
        - key: redis-config
          path: redis.conf
EOF

// create pod
kubectl create -f pod.yaml
----

[source, yaml]
.*3. 验证*
----
# kubectl exec -it redis redis-cli
127.0.0.1:6379> CONFIG GET maxmemory
1) "maxmemory"
2) "2097152"
127.0.0.1:6379> CONFIG GET maxmemory-policy
1) "maxmemory-policy"
2) "allkeys-lru"
----

=== Ngnix 运行参数(ENV 参数对接 ConfigMap)

[source, yaml]
.*1. 创建 nginx-config*
----
kubectl create configmap nginx-config --from-literal=username=kylin --from-literal=password=password
----

[source, yaml]
.*2. 创建一个 POD*
----
// prepare yaml files
cat <<EOF > ./pod-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
    env:
    - name: NGINX_USERNAME
      valueFrom:
        configMapKeyRef:
          name: nginx-config
          key: username 
    - name: NGINX_PASSWORD
      valueFrom:
        configMapKeyRef:
          name: nginx-config
          key: password
  dnsPolicy: ClusterFirst
  restartPolicy: Always
EOF

// create pod
kubectl create -f pod-nginx.yaml
----

[source, yaml]
.*3. 验证*
----
# kubectl exec nginx env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=nginx
NGINX_PASSWORD=password
NGINX_USERNAME=kylin
----

== Pod 亲和性策略

=== nodeSelector

[source, yaml]
.*1. 设定 nodes label*
----
kubectl label node machine03.example.com disk=ssd

kubectl get nodes -l disk=ssd
----

[source, yaml]
.*2. 部署 Pod 到 node*
----
// create pod yaml
cat <<EOF > ./pod-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  nodeSelector:
    disk: ssd
  dnsPolicy: ClusterFirst
  restartPolicy: Always
EOF

// create pod
kubectl create -f pod-nginx.yaml 
----

[source, yaml]
.*3. 验证*
----
# kubectl get pods -o wide --no-headers
nginx   1/1   Running   0     64s   192.168.208.224   machine03.example.com   <none>   <none>
----

=== Node affinity

[source, yaml]
.*1. 设定 nodes label*
----
kubectl label node machine03.example.com example.com/zone=zone1

kubectl get nodes -l example.com/zone=zone1
----

[source, yaml]
.*2. 部署 Pod 到 node*
----
// create pod yaml
cat <<EOF > ./pod-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
       nodeSelectorTerms:
       - matchExpressions:
         - key: example.com/zone
           operator: In
           values:
           - zone1
           - zone2
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchExpressions:
          - key: example.com/disk
            operator: In
            values:
            - ssd
  dnsPolicy: ClusterFirst
  restartPolicy: Always
EOF

// create pod
kubectl create -f pod-nginx.yaml 
----

.*3. 验证*
----
# kubectl get pods -o wide --no-headers
nginx   1/1   Running   0     64s   192.168.208.224   machine03.example.com   <none>   <none>
----

=== Pod affinity

=== nodeName

[source, yaml]
.*1. 部署 Pod 到 node*
----
// create pod yaml
cat <<EOF > ./pod-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  nodeName: machine02.example.com
  dnsPolicy: ClusterFirst
  restartPolicy: Always
EOF

// create pod
kubectl create -f pod-nginx.yaml
----

[source, yaml]
.*2. 验证*
----
# kubectl get pods -o wide --no-headers
nginx   1/1   Running   0     20s   192.168.251.35   machine02.example.com   <none>   <none>
----

=== DaemonSet

[source, yaml]
.*1. 部署 Pod 到 node*
---- 
// create daemonset yaml
cat <<EOF > ./daemonset.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      name: nginx
  template:
    metadata:
      labels:
        name: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
EOF

// create 
kubectl create -f daemonset.yaml
----

[source, yaml]
.*2. 验证*
----
# kubectl get pods -o wide --no-headers
nginx-8x4tq   1/1   Running   0     57s   192.168.251.38    machine02.example.com   <none>   <none>
nginx-krp9l   1/1   Running   0     57s   192.168.208.225   machine03.example.com   <none>   <none>
----

=== Tolerations

[source, yaml]
.*1. 部署 Pod 到 node*
----
// create pod yaml
cat <<EOF > ./pod-nginx.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: nginx
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    ports:
    - containerPort: 80
    resources: {}
  tolerations:
  - key: "node-role.kubernetes.io/master"
    operator: "Exists"
    effect: "NoSchedule"
  dnsPolicy: ClusterFirst
  restartPolicy: Always
EOF

// create pod
kubectl create -f pod-nginx.yaml
----

[source, yaml]
.*2. 验证*
----
# kubectl get pods -o wide --no-headers
----

== 无状态应用

=== External Load Balancer

[source, yaml]
.*1. create a deployment.yaml*
----
cat <<EOF > ./deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: load-balancer-example
  name: hello-world
spec:
  replicas: 5
  selector:
    matchLabels:
      app.kubernetes.io/name: load-balancer-example
  template:
    metadata:
      labels:
        app.kubernetes.io/name: load-balancer-example
    spec:
      containers:
      - image: gcr.io/google-samples/node-hello:1.0
        name: hello-world
        ports:
        - containerPort: 8080
EOF
----

[source, yaml]
.*2. deploy*
----
# kubectl apply -f deployment.yaml 
deployment.apps/hello-world created
----

[source, yaml]
.*3. view the deployment details*
----
// view all
kubectl get all

// view the details of Deployment
kubectl describe deployment.apps/hello-world

// view the details of ReplicaSet
kubectl describe  replicaset.apps/hello-world-f9b447754 

// view the pods distribution
# kubectl get pods -o wide
NAME                          READY   STATUS    RESTARTS   AGE     IP                NODE                    NOMINATED NODE   READINESS GATES
hello-world-f9b447754-4cqrn   1/1     Running   0          4m37s   192.168.251.5     machine02.example.com   <none>           <none>
hello-world-f9b447754-cvhgm   1/1     Running   0          4m37s   192.168.251.6     machine02.example.com   <none>           <none>
hello-world-f9b447754-cxwm6   1/1     Running   0          4m37s   192.168.208.199   machine03.example.com   <none>           <none>
hello-world-f9b447754-tvq9v   1/1     Running   0          4m37s   192.168.208.198   machine03.example.com   <none>           <none>
hello-world-f9b447754-v85fw   1/1     Running   0          4m37s   192.168.208.197   machine03.example.com   <none>           <none>
----

[source, yaml]
.*4. Create LB Service*
----
// create
kubectl expose deployment hello-world --type=LoadBalancer --name=my-service

// view service
# kubectl get services my-service
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
my-service   LoadBalancer   10.100.32.120   <pending>     8080:31059/TCP   7m8s
----

[source, yaml]
.*5. edit service, add a external IP(external lb), the externalIPs is added*
----
# kubectl edit service/my-service
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2020-02-20T08:53:43Z"
  labels:
    app.kubernetes.io/name: load-balancer-example
  name: my-service
  namespace: default
  resourceVersion: "185225"
  selfLink: /api/v1/namespaces/default/services/my-service
  uid: 6667dd2b-9ebb-499f-b202-b0539d75df1a
spec:
  clusterIP: 10.100.32.120
  externalTrafficPolicy: Cluster
  ports:
  - nodePort: 31059
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app.kubernetes.io/name: load-balancer-example
  sessionAffinity: None
  type: LoadBalancer
  externalIPs:
  - 192.168.100.102
status:
  loadBalancer: {}
----

[source, yaml]
.*5. view the services*
----
# kubectl get svc my-service
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)          AGE
my-service   LoadBalancer   10.100.32.120   192.168.100.102   8080:31059/TCP   14m
----

[source, yaml]
.*6. access the application*
----
# curl http://192.168.100.102:8080
Hello Kubernetes!
----

[source, yaml]
.*7. clean up*
----
kubectl delete all --all
----

=== Guestbook 示例

[source, yaml]
.*1. 部署 Redis Master*
----
// 1. create the deployment yaml
cat <<EOF > ./redis-master-deployment.yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: redis-master
  labels:
    app: redis
spec:
  selector:
    matchLabels:
      app: redis
      role: master
      tier: backend
  replicas: 1
  template:
    metadata:
      labels:
        app: redis
        role: master
        tier: backend
    spec:
      containers:
      - name: master
        image: k8s.gcr.io/redis:e2e  # or just image: redis
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379
EOF

// 2. deploy
kubectl apply -f redis-master-deployment.yaml 

// 3. view deployments
kubectl get all

// 4. view redis logs
kubectl logs -f pod/redis-master-7db7f6579f-j2bbv
----

[source, yaml]
.*2. 给 Redis Master 创建一个 Service*
----
// 1. create the service yaml
cat <<EOF > ./redis-master-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-master
  labels:
    app: redis
    role: master
    tier: backend
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis
    role: master
    tier: backend
EOF

// 2. create service
kubectl apply -f redis-master-service.yaml 

// 3. view the services
kubectl get svc
kubectl describe svc redis-master
----

[source, yaml]
.*3. 部署 2 个 Redis Slave 节点*
----
// 1. create the deployment yaml
cat <<EOF > ./redis-slave-deployment.yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: redis-slave
  labels:
    app: redis
spec:
  selector:
    matchLabels:
      app: redis
      role: slave
      tier: backend
  replicas: 2
  template:
    metadata:
      labels:
        app: redis
        role: slave
        tier: backend
    spec:
      containers:
      - name: slave
        image: gcr.io/google_samples/gb-redisslave:v3
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 6379
EOF

// 2. deploy
kubectl apply -f redis-slave-deployment.yaml 

// 3. view the deployments
kubectl get all -l role=slave
----

[source, yaml]
.*4. 给 Redis Slave 创建一个 Service*
----
// 1. create the service yaml
cat <<EOF > ./redis-slave-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-slave
  labels:
    app: redis
    role: slave
    tier: backend
spec:
  ports:
  - port: 6379
  selector:
    app: redis
    role: slave
    tier: backend
EOF

// 2. create service
kubectl apply -f redis-slave-service.yaml 

// 3. view the service
kubectl get svc -l role=slave
kubectl describe svc redis-slave 
----

[source, yaml]
.*5. 部署 Guestbook*
----
// 1. create the deployment yaml
cat <<EOF > ./frontend-deployment.yaml
apiVersion: apps/v1 # for versions before 1.9.0 use apps/v1beta2
kind: Deployment
metadata:
  name: frontend
  labels:
    app: guestbook
spec:
  selector:
    matchLabels:
      app: guestbook
      tier: frontend
  replicas: 3
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: gcr.io/google-samples/gb-frontend:v4
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
        - name: GET_HOSTS_FROM
          value: dns
        ports:
        - containerPort: 80
EOF

// 2. deploy
kubectl apply -f frontend-deployment.yaml 

// 3. view the deploy details
kubectl get all -l app=guestbook
----

[source, yaml]
.*6. 给 Guestbook 创建一个服务*
----
// 1. create the service yaml
cat <<EOF > ./frontend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  type: NodePort 
  ports:
  - port: 80
  selector:
    app: guestbook
    tier: frontend
EOF

// 2. create svc
kubectl apply -f frontend-service.yaml 

// 3. view service
kubectl get svc -l app=guestbook 
kubectl describe svc frontend
----

[source, yaml]
.*7. 查看部署完成后的集群*
----
# kubectl get pods -o wide
NAME                            READY   STATUS    RESTARTS   AGE   IP                NODE                    NOMINATED NODE   READINESS GATES
frontend-6cb7f8bd65-6b76c       1/1     Running   0          20m   192.168.251.9     machine02.example.com   <none>           <none>
frontend-6cb7f8bd65-p66hr       1/1     Running   0          20m   192.168.208.204   machine03.example.com   <none>           <none>
frontend-6cb7f8bd65-pz78j       1/1     Running   0          20m   192.168.208.203   machine03.example.com   <none>           <none>
redis-master-7db7f6579f-j2bbv   1/1     Running   0          46m   192.168.251.7     machine02.example.com   <none>           <none>
redis-slave-7664787fbc-5b6ds    1/1     Running   0          33m   192.168.251.8     machine02.example.com   <none>           <none>
redis-slave-7664787fbc-lr7bp    1/1     Running   0          33m   192.168.208.202   machine03.example.com   <none>           <none>

# kubectl get deployments
NAME           READY   UP-TO-DATE   AVAILABLE   AGE
frontend       3/3     3            3           21m
redis-master   1/1     1            1           47m
redis-slave    2/2     2            2           33m

# kubectl get svc
NAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
frontend       NodePort    10.110.209.79   <none>        80:32465/TCP   17m
kubernetes     ClusterIP   10.96.0.1       <none>        443/TCP        58m
redis-master   ClusterIP   10.97.142.208   <none>        6379/TCP       40m
redis-slave    ClusterIP   10.104.96.140   <none>        6379/TCP       29m

# kubectl get rs
NAME                      DESIRED   CURRENT   READY   AGE
frontend-6cb7f8bd65       3         3         3       22m
redis-master-7db7f6579f   1         1         1       47m
redis-slave-7664787fbc    2         2         2       34m
----

*8. 访问 Guestbook*

浏览器打开 http://192.168.100.101:32465/

[source, yaml]
.*9. Clean up*
----
kubectl delete all --all
----

== 有状态应用

=== 基本概念

[source, yaml]
.*1. 创建一个 StatefulSet*
----
// 1. create the web yaml
cat <<EOF > ./web.yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: "nginx"
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
EOF

// 2. create
kubectl apply -f web.yaml

// 3. view the creation

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----

[source, yaml]
----

----



